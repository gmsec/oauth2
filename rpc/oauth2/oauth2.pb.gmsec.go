// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package oauth2

import (
	context "context"
	micro "github.com/gmsec/micro"
	client "github.com/gmsec/micro/client"
	server "github.com/gmsec/micro/server"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface
var _ server.Server
var _ client.Client
var _ micro.Service

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// Oauth2Client is the client API for Oauth2 service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type Oauth2Client interface {
	// Authorize 授权获取令牌
	Authorize(ctx context.Context, in *AuthorizeReq, opts ...grpc.CallOption) (*AuthorizeResp, error)
	// CheckToken 校验token，并获取详细信息
	CheckToken(ctx context.Context, in *CheckTokenReq, opts ...grpc.CallOption) (*CheckTokenResp, error)
	// RefreshToken 刷新token
	RefreshToken(ctx context.Context, in *RefreshTokenReq, opts ...grpc.CallOption) (*RefreshTokenResp, error)
	// Login 登录
	Login(ctx context.Context, in *LoginReq, opts ...grpc.CallOption) (*LoginResp, error)
}

type oauth2Client struct {
	cc client.Client
}

// GetOauth2Name get client name(package.class)
func GetOauth2Name() string {
	return "oauth2.Oauth2"
}

// GetOauth2Client get client by clientname
func GetOauth2Client() Oauth2Client {
	cc := micro.GetClient(GetOauth2Name())
	return &oauth2Client{cc}
}

// GetOauth2ClientByName get client by custom name
func GetOauth2ClientByName(name string) Oauth2Client {
	cc := micro.GetClient(name)
	return &oauth2Client{cc}
}

func NewOauth2Client(cc client.Client) Oauth2Client {
	return &oauth2Client{cc}
}

func (c *oauth2Client) Authorize(ctx context.Context, in *AuthorizeReq, opts ...grpc.CallOption) (*AuthorizeResp, error) {
	conn, err := c.cc.Next()
	defer conn.Close()
	if err != nil {
		return nil, err
	}
	out := new(AuthorizeResp)
	err = conn.Invoke(ctx, "/oauth2.Oauth2/Authorize", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *oauth2Client) CheckToken(ctx context.Context, in *CheckTokenReq, opts ...grpc.CallOption) (*CheckTokenResp, error) {
	conn, err := c.cc.Next()
	defer conn.Close()
	if err != nil {
		return nil, err
	}
	out := new(CheckTokenResp)
	err = conn.Invoke(ctx, "/oauth2.Oauth2/CheckToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *oauth2Client) RefreshToken(ctx context.Context, in *RefreshTokenReq, opts ...grpc.CallOption) (*RefreshTokenResp, error) {
	conn, err := c.cc.Next()
	defer conn.Close()
	if err != nil {
		return nil, err
	}
	out := new(RefreshTokenResp)
	err = conn.Invoke(ctx, "/oauth2.Oauth2/RefreshToken", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *oauth2Client) Login(ctx context.Context, in *LoginReq, opts ...grpc.CallOption) (*LoginResp, error) {
	conn, err := c.cc.Next()
	defer conn.Close()
	if err != nil {
		return nil, err
	}
	out := new(LoginResp)
	err = conn.Invoke(ctx, "/oauth2.Oauth2/Login", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Oauth2Server is the server API for Oauth2 service.
type Oauth2Server interface {
	// Authorize 授权获取令牌
	Authorize(context.Context, *AuthorizeReq) (*AuthorizeResp, error)
	// CheckToken 校验token，并获取详细信息
	CheckToken(context.Context, *CheckTokenReq) (*CheckTokenResp, error)
	// RefreshToken 刷新token
	RefreshToken(context.Context, *RefreshTokenReq) (*RefreshTokenResp, error)
	// Login 登录
	Login(context.Context, *LoginReq) (*LoginResp, error)
}

// UnimplementedOauth2Server can be embedded to have forward compatible implementations.
type UnimplementedOauth2Server struct {
}

func (*UnimplementedOauth2Server) Authorize(context.Context, *AuthorizeReq) (*AuthorizeResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Authorize not implemented")
}
func (*UnimplementedOauth2Server) CheckToken(context.Context, *CheckTokenReq) (*CheckTokenResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CheckToken not implemented")
}
func (*UnimplementedOauth2Server) RefreshToken(context.Context, *RefreshTokenReq) (*RefreshTokenResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RefreshToken not implemented")
}
func (*UnimplementedOauth2Server) Login(context.Context, *LoginReq) (*LoginResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Login not implemented")
}

func RegisterOauth2Server(s server.Server, srv Oauth2Server) {
	s.GetServer().RegisterService(&_Oauth2_serviceDesc, srv)
}

func _Oauth2_Authorize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthorizeReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Oauth2Server).Authorize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/oauth2.Oauth2/Authorize",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Oauth2Server).Authorize(ctx, req.(*AuthorizeReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Oauth2_CheckToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckTokenReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Oauth2Server).CheckToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/oauth2.Oauth2/CheckToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Oauth2Server).CheckToken(ctx, req.(*CheckTokenReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Oauth2_RefreshToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RefreshTokenReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Oauth2Server).RefreshToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/oauth2.Oauth2/RefreshToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Oauth2Server).RefreshToken(ctx, req.(*RefreshTokenReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Oauth2_Login_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LoginReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(Oauth2Server).Login(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/oauth2.Oauth2/Login",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(Oauth2Server).Login(ctx, req.(*LoginReq))
	}
	return interceptor(ctx, in, info, handler)
}

var _Oauth2_serviceDesc = grpc.ServiceDesc{
	ServiceName: "oauth2.Oauth2",
	HandlerType: (*Oauth2Server)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Authorize",
			Handler:    _Oauth2_Authorize_Handler,
		},
		{
			MethodName: "CheckToken",
			Handler:    _Oauth2_CheckToken_Handler,
		},
		{
			MethodName: "RefreshToken",
			Handler:    _Oauth2_RefreshToken_Handler,
		},
		{
			MethodName: "Login",
			Handler:    _Oauth2_Login_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "oauth2/oauth2.proto",
}
